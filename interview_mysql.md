## MyISAM索引与InnoDB索引的区别
- InnoDB支持事务，MyISAM不支持
- InnoDB支持外键，而MyISAM不支持
- InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
- InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）
- Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高
- MyISAM表格可以被压缩后进行查询操作
- InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁
- InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有
- Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI
- InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。

- MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。

- InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效
- innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高
- 如何选择存储引擎
    - 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
    - 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。
    - 系统奔溃后，MyISAM恢复起来更困难，能否接受；

## InnoDB引擎的4大特性
- 1、插入缓冲（insert buffer)

- 2、二次写(double write)

- 3、自适应哈希索引(ahi)

- 4、预读(read ahead)

## 数据库相关
- 事物的隔离级别
    - 读未提交
    - 读提交 解决脏读
    - 可重复读 解决不可重复读
    - 串行化    幻读
- 如何解决不可重复读？
    - mvcc（[查看mvcc的原理](https://processon.com/diagraming/61dec1c11e085306c9666fe9)）
- mysql MVCC底层原理

- 数据库什么情况下走索引，什么情况下不走索引
    - mysql认为全局遍历比走索引快的时候就会放弃索引，
    - 索引一般都是重复率低，或者不重复
    - 如果对性别只有男女进行索引，这种b+树只有一层，没必要走索引
- 第一类索引，第二类索引
    - 第一类丢失更新(回滚丢失，Lost update)，
        - A事务撤销时，把已经提交的B事务的更新数据覆盖了。
        - A事务在撤销时，“不小心”将B事务已经转入账户的金额给抹去了
    - 第二类丢失更新(覆盖丢失/两次更新问题，Second lost update)
        - A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失


## 创建索引时需要注意什么
- 非空字段：应该指定列为 NOT NULL，除非你想存储 NULL
- 取值离散大的字段
- 索引字段越小越好

## 创建索引的规则
- 主键外键必须有索引
- 数据量超过300的表应该有索引
- 经常与其他表进行连接的表，在连接字段上应该建立索引；
- 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引
- 索引应该建在选择性高的字段上
- 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引
- 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替
    - A、正确选择复合索引中的主列字段，一般是选择性较好的字段；
    - B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；
    - C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
    - E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；
- 频繁进行数据操作的表，不要建立太多的索引；
- 删除无用的索引，避免对执行计划造成负面影响
    - 索引对于插入、删除、更新操作也会增加处理上的开销
    - 比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引
    - 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的


## 百万级别或以上的数据如何删除
    - 先删除索引
    - 删除无用的数据
    - 删除完成后重新创建索引

## 什么是最左前缀原则？什么是最左匹配原则
    - mysql 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如 a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整

## 什么是聚簇索引？何时使用聚簇索引与非聚簇索引
    - 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
    - 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行

## 什么是临时表，何时删除临时表？
    - MySQL 在执行 SQL 语句的过程中 通常会临时创建一些存储中间结果集的表
    - 内存临时表使用的是 MEMORY 存储引擎，而临时表采用的是 MylSAM 存储引擎
    - 使用 UNION 会去掉两个表中的重复数据，相当于对
结果集做了一下 去重(distinct)

## 建立索引的原则
    - 1、表的主键、外键必须有索引；
    - 2、数据量超过300的表应该有索引；
    - 3、经常与其他表进行连接的表，在连接字段上应该建立索引
    - 4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
    - 5、索引应该建在选择性高的字段上；
    - 6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
    - 7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：
        - A、正确选择复合索引中的主列字段，一般是选择性较好的字段；
        - B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；
        - C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
        - D、如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；
        - E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引;
    - 8、频繁进行数据操作的表，不要建立太多的索引；
    - 9、删除无用的索引，避免对执行计划造成负面影响； 以上是一些普遍的建立索引时的判断依据
## mysql的change buffer的作用？唯一索引，普通索引中用到？

~~~markdown
mysql8.0 change buffer ： [源码说明](https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html)
	解释：change buffer 顾名思义是 ‘更改’缓存，就是对数据库 更改 动作的一个缓存，但是缓存的是那些不在buffer pool的二级索引页的一些MDL（insert update delete）操作的，随后当遇到一些相关其他的读操作，mysql会‘一起’将他们merge到buffer pool里，然后buffer pool里的内容会purge（清洗或者理解成flush）到disk存储中，当然也有定时任务会对change buffer 和 buffer pool的内容进行合并。和聚簇索引不一样，普通索引一般都不唯一，在业务中插入二级索引比较常见且顺序随机，删除和更新等操作很可能会影响那些相邻的二级索引页，稍后合并缓存的更改，当受影响的页面被其他操作读入缓冲池时，避免了将二级索引页面从磁盘读入缓冲池所需的大量随机访问 I/O。在系统大部分空闲或缓慢关闭期间运行的清除操作会定期将更新的索引页写入磁盘。与将每个值立即写入磁盘相比，purge操作可以更有效地为一系列索引值写入磁盘块。
	
	注意：官网原文：Change buffering is not supported for a secondary index if the index contains a descending index column or if the primary key includes a descending index column. 如果索引包含了降序索引列或者主键包含降序索引列，那就不支持使用change buffer了。这可能是排查问题的一个好点子，具体可查FAQ：https://dev.mysql.com/doc/refman/8.0/en/faqs-innodb-change-buffer.html
	
	特点（注意点）：
		1. 虽然叫change buffer，实际上是可持久化的数据。即change buffer在内存中有拷贝，也会被写进磁盘（change buffer的操作也记录到redo log）
		2. change buffer 只支持二级索引。聚簇，全文，空间索引都不支持，特别是全文索引，有他自己的缓存机制
		3. change buffer是 buffer pool 的部分 5.6版本change buffer最多可以使用30%，5.6之后最多50%，默认是25%。change buffer不会一直存在，LRU算法会进行淘汰
		4. 简单来说为了减少随机IO 的发生，change buffer适合应用在写多读少，该类业务模型常见为账单、日志类的系统。假设一业务的更新模式是写后马上查询，那么即使满足条件，将更新先记录在change buffer，但之后由于马上要访问该数据页，立即触发merge。这样随机访问IO的次数不会减少，反而增加change buffer维护代价。所以，对于这种业务模式，change buffer起反作用。
		5. redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。
		
	作用：当操作更新一个数据页时
		- 若数据页在内存（buffer pool），直接更新
		- 若该数据页不在内存，在不影响数据一致性前提下，InooDB会将这些更新操作缓存在change buffer，无需从磁盘读入该数据页，在下次查询需要访问该数据页	    	   时，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过该方式就能保证这个数据逻辑的正确性。

change buffer 和 二级索引、唯一索引有什么关系呢？
	刚才上面提到了，change buffer本质还是为了提高性能的，基本都是涉及到了二级索引页的变更。那如果涉及到唯一索引呢？
	对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束！因此，这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了【没想到吧>._.<】。，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。


~~~





## 查询很慢怎么排查和优化？
## EXPLAIN有什么用途？有哪些字段？
## InnoDB索引底层实现？为什么使用b+树不适用b树？
## 什么是覆盖索引？什么是回表？
## MySQL的ACID怎么实现？
## 有哪些隔离级别？实现原理？
## 脏读、幻读概念？怎么解决幻读的问题？间隙锁是什么？可重复读怎么实现？
## MySQL怎么实现高可用？
## 生产环境如何修改表结构
## 自增id到了最大，再insert一条数据会发生什么？
## 从分组的结果中选出最大的5个数
## group和having的区别 
## 千万条数据如何迁移
## 什么是mysql
## 什么是b+树

## 2022-01-19收录
- 你碰到过的数据库优化最难的问题，及如何解决
- mysql 索引覆盖，回表 （滴滴）
- 忘了加唯一索引有啥补救措施吗
  - 只是参考答案：新增别出现相同数据就好
- 在唯一索引的约束下，如何优雅地软删除
- 需求: 一张表中有个字段appid，同一个appid只允许存在一行正常记录，但是可以存在多条软删除记录
  - 答案：额外加一个status字段，0为正常，非零为已删除。和appid作为复合唯一索引，软删除的时候将status改为当前时间戳
- mysql索引的类型，各自的特点，还有索引失效的情况
- 腾讯外包公司题：
  - mysql唯一索引是否可以为null？为什么？
  - select for update是表锁还是行锁？（仔细查找答案，有坑）
  - 乐观锁和悲观锁数据库层面如何实现？
  - 缓存数据和数据库数据如何实现一致性？

- 使用索引查询一定能提高查询的性能吗？为什么

- MVCC机制原理以及RR隔离级别下如何通过MVCC机制解决脏读，不可重复读，幻读的问题？
- 事务还没提交的时候，redolog 能不能被持久化到磁盘呢(字节一面)
  - [解释参考](https://mp.weixin.qq.com/s/kdPb4v5nOu0LMCj8s1ETNg)

- mysql 联合查询用法
- mysql group用法
- mysql group by  having 和 where 执行顺序
- mysql 索引有哪些
- mysql 主键索引和二级索引有什么区别
- mysql 做过哪些优化
- Mysql 默认的隔离级别是什么？在 Innodb 的可重复读的情况下可以解决幻读的情况吗？（字节）
- slice和数组的区别